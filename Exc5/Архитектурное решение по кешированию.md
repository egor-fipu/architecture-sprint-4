### Архитектурное решение по кешированию

---

#### Мотивация

**Проблема**: 
- Операторы и клиенты сталкиваются с низкой скоростью работы MES, что негативно влияет на общую производительность системы и удовлетворённость пользователей.

**Причины**: 
- Высокая нагрузка на базу данных MES из-за частых чтений данных о заказах и долгих операций обновления.

**Цели кеширования**:
1. Ускорение операций чтения списка заказов и других часто запрашиваемых данных.
2. Снижение нагрузки на базу данных.
3. Повышение скорости реакции интерфейса для операторов и пользователей.

**Элементы системы для кеширования**:
- **Чтение списка заказов**: Список заказов с их текущими статусами.
- **Справочные данные**: Часто используемые данные, такие как список товаров, статусы заказов, шаблоны операций.
- **Краткосрочные результаты расчётов**: Например, данные о предполагаемом времени выполнения заказа.

---

#### Предлагаемое решение

**Тип кеширования**: 
- **Серверное кеширование**:
  - **Почему серверное**: Оно позволяет централизованно контролировать доступ к данным, повышает предсказуемость системы и подходит для многопользовательских сценариев (MES используется одновременно большим количеством операторов).
  - Клиентское кеширование может дополнительно применяться для статичных данных, таких как справочные материалы, но для критичных бизнес-данных требуется больше контроля.

**Паттерн кеширования**: 
- **Write-Through**:
1. Данные в кэше всегда синхронизированы с базой данных.
2. Устранение проблемы неактуальных данных, так как запись сразу обновляет и кэш, и базу.
3. Подходит для сценариев с частыми изменениями данных (например, новые заказы, изменение статусов).

**Процесс работы**:

1. **Чтение списка заказов:**
   - Система всегда проверяет кэш. Если данные есть в кэше, они возвращаются.
   - Если данных нет (например, заказ был только что создан), они берутся из базы данных, кэшируются и возвращаются.

2. **Запись изменений:**
   - При добавлении нового заказа или изменении статуса запись сначала выполняется в кэш, а затем в базу данных.
   - Это гарантирует, что кэш всегда содержит актуальные данные.

---

#### Диаграмма последовательности

[Диаграмма последовательности](diagram.puml)

---

#### Стратегия инвалидации кеша

**Выбранная стратегия**: Инвалидация по ключу.
- **Почему**:
  - Чёткая связь между ключами и данными позволяет минимизировать влияние на производительность.
  - Удобно обновлять данные только для конкретного заказа или справочной записи.
- **Почему не подходят другие стратегии**:
  - **Временная инвалидация** может привести к устаревшим данным, что критично для операций со статусами заказов.
  - **Программная инвалидация** требует дополнительных механизмов для определения устаревших данных, что усложняет реализацию.

**Дополнительно**: 
- Настроить **TTL** для данных справочной информации (например, 24 часа).
- Для данных заказов использовать явную инвалидацию по событию (например, изменение статуса).

---

#### Сравнительный анализ стратегий инвалидации

1. **Временная инвалидация**:
   - Удобна для данных, которые нечасто меняются и имеют предсказуемый срок актуальности.
   - Простая реализация: достаточно задать TTL (time-to-live) для каждого элемента кеша.
   - Недостаток: возможны ситуации, когда данные устаревают до истечения TTL, либо наоборот, данные всё ещё актуальны, но кеш уже удалён.

2. **Инвалидация по ключу**:
   - Подходит для динамических данных с чёткой идентификацией (например, статус конкретного заказа).
   - Позволяет вручную удалять или обновлять данные в кеш при изменении в исходной системе.
   - Требует разработки и строгого соблюдения структуры ключей.

3. **Программная инвалидация**:
   - Применяется для сложных сценариев, когда нужно автоматически определять устаревшие данные.
   - Требует дополнительной логики, например, отслеживания зависимостей между элементами данных.
   - Наиболее сложна в реализации, но эффективна в системах с высокой изменчивостью данных.

---

#### Технологии:
1. **Redis**: Для высокоскоростного кэширования и поддержания актуальности данных.
2. **Middleware**: Для реализации Write-Through (например, Redis OM, библиотеки для конкретных языков).

---
